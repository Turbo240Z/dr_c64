; Interup based timing events

RASTER_TO_COUNT_AT  .equ 220
DELAY2              .equ 6
SID_VOLUME          .equ $D418
songStartAdress     .equ $8000
SOUND_ROTATE        .byte $00,$f6,$00,$a0,$12,$c0,$d0,$d1,$d2,$d4,$d6,$d8,$da,$10,$00
SOUND_HORIZONTAL    .byte $00,$53,$00,$a0,$12,$c0,$d0,$d1,$d2,$d4,$d6,$d8,$da,$10,$00
SOUND_BOTTOM        .byte $82,$24,$00,$a0,$81,$90,$41,$8e,$8a,$40,$00
SOUND_CLEAR         .byte $01, $93, $00, $c4, $81, $c4, $c4, $c4, $21, $c4, $c0, $c7, $c0, $c6, $c0, $c4, $c0, $c4, $80, $00
refreshCount        .byte $00
refreshTimer2       .byte $00
refreshTimer3       .byte $00
refreshTimer4       .byte $00 ; Keep track of frames since virus last animated
playMusic           .byte $00

initRefreshCounter
    sei          ; turn off interrupts
    lda #$7f
    sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips
    sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
               ;stop it.

    lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.
    lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
           ;we don't want that to happen.
    lda #$01   ;this is how to tell the VICII to generate a raster interrupt
    sta $d01a



    ; Configure ROM/RAM
    lda #$35   ;we turn off the BASIC and KERNAL rom here
    sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
           ;SID/VICII/etc are visible

    ; Set video mode
    lda #%00011011 ; screen on, 25 rows : this is default
    sta $d011
    lda #%00001000 ; 40 columns, single color mode
    sta $d016

    lda #RASTER_TO_COUNT_AT     ; line to trigger interrupt
    sta $d012

    lda #<irq_refreshCounter    ; low part of address of interrupt handler code
    sta $fffe
    lda #>irq_refreshCounter    ; high part of address of interrupt handler code
    sta $ffff
    cli          ; turn interrupts back on
    rts

;
; Event entry point
irq_refreshCounter ; void (y, x, a)
    pha        ;store register A in stack
    txa
    pha        ;store register X in stack
    tya
    pha        ;store register Y in stack
    jsr cycleAnimatedViruses
    ; See if we need to turn off a score sprite
    lda $d015
    and #4
    beq noScoreSpriteEnabled
    lda framesToShowSprite
    beq disableScoreSprite
    cmp #15
    bne noScoreSpriteMods
    ; For 15 do
    lda #COLOR_GREY
    sta VMEM+41
    dec $d005
    dec $d005
    jmp noScoreSpriteMods

    cmp #5
    lda #COLOR_DARK_GREY
    sta VMEM+41
    dec $d005
    dec $d005

noScoreSpriteMods
    dec framesToShowSprite
    jmp noScoreSpriteEnabled
disableScoreSprite
    ; everything except for sprite 3 enabled
    lda $d015
    and #%11111011
    sta $d015
noScoreSpriteEnabled

    lda playMusic
    beq dontPlayMusic
    jsr songStartAdress+3 ; Play song
dontPlayMusic
    inc refreshCount
    inc refreshTimer2
    inc refreshTimer3

; For input timers, these shouldn't roll over
    ldx #10 ; cached value for reseting a roll over

    inc f_repeatTime ; Fire button repeat
    bne fNoReset
    stx f_repeatTime
fNoReset
    inc r_repeatTime
    bne rNoReset
    stx r_repeatTime
rNoReset
    inc l_repeatTime
    bne lNoReset
    stx l_repeatTime
lNoReset
    inc d_repeatTime
    lda refreshTimer3
    cmp DELAY
    bne noRefreshTimer3Work
    lda #0
    sta refreshTimer3

;    jsr cycleBackgroundAnimation
noRefreshTimer3Work
    asl $d019    ; ACK interrupt (to re-enable it)
    pla
    tay
    pla
    tax
    pla
    rti          ; return from interrupt


WaitEventFrame
    lda #0
    sta refreshTimer2
waitStart
    lda #DELAY2
    cmp refreshTimer2
    bcc waitDone ; >= than DELAY2
    jmp waitStart
waitDone
    rts

